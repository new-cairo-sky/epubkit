"use strict";Object.defineProperty(exports, "__esModule", { value: true });exports.fontObfuscation = fontObfuscation;exports.idpfFontObfuscation = idpfFontObfuscation;exports.adobeFontObfuscation = adobeFontObfuscation;exports.getAdobeKeyFromIdentifier = getAdobeKeyFromIdentifier;exports.getIdpfKeyFromIdentifier = getIdpfKeyFromIdentifier;var _jssha = _interopRequireDefault(require("jssha"));
var _utf = _interopRequireDefault(require("utf8"));
var _xml = require("./utils/xml.js");function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { default: obj };}

/**
 * The Epub font obfuscation spec is a self-inverting XOR process.
 * To unobfuscate just run the obfuscated font through the obfuscator again.
 * Based on the java implementations found at
 * https://github.com/dita4publishers/epub-font-obfuscator
 * and the C++ implementation at:
 * https://github.com/Sigil-Ebook/Sigil/blob/master/src/Misc/FontObfuscation.cpp
 *
 * The spec is found at:
 * https://www.w3.org/publishing/epub32/epub-ocf.html#sec-resource-obfuscation
 */

/**
 * Uses the data from the package Opf and encryption.xml to find obfuscation method and key
 * TODO: this assumes that all fonts are obfuscated with the same method
 * The fontLocation option should be used to id the font obfuscation method within encrpytion.xml
 * @param {Buffer | Uint8Array} fontData - source font data
 * @param {string} opfXml - xml of opf file
 * @param {string} encryptionXml - xml of encryption.xml file
 * @param {string} fontLocation - (optional) the location of the font relative to the epub root
 */
async function fontObfuscation(
fontData,
opfXml,
encryptionXml,
fontLocation = undefined)
{var _fontEncryptedData, _fontEncryptedData$en, _fontEncryptedData$en2;
  const parsedOpfXml = await (0, _xml.parseXml)(opfXml);
  const parsedEncryptionXml = await (0, _xml.parseXml)(encryptionXml);
  const packageUniqueIdName = parsedOpfXml.package.attr["unique-identifier"];
  const uniqueIdEl = parsedOpfXml.package.metadata[0]["dc:identifier"].find(
  idEl => {
    return idEl.attr.id === packageUniqueIdName;
  });

  const uniqueId = uniqueIdEl.val;

  let fontEncryptedData;
  if (fontLocation) {var _parsedEncryptionXml$;
    // if fontLocation is provided, look for it in the encryption references
    fontEncryptedData = parsedEncryptionXml === null || parsedEncryptionXml === void 0 ? void 0 : (_parsedEncryptionXml$ = parsedEncryptionXml.encryption) === null || _parsedEncryptionXml$ === void 0 ? void 0 : _parsedEncryptionXml$[
    "enc:encrypteddata"].
    find(encryptedData => {var _encryptedData$encCi, _encryptedData$encCi$;
      const cipherReference = encryptedData === null || encryptedData === void 0 ? void 0 : (_encryptedData$encCi = encryptedData["enc:cipherdata"]) === null || _encryptedData$encCi === void 0 ? void 0 : (_encryptedData$encCi$ = _encryptedData$encCi[0]) === null || _encryptedData$encCi$ === void 0 ? void 0 : _encryptedData$encCi$[
      "enc:cipherreference"].
      find(ref => ref.attr.uri === fontLocation);
      if (cipherReference) {
        return true;
      } else {
        return false;
      }
    });
  } else {
    // otherwise look to see if either adobe or idpf is listed at all and take the first one found
    fontEncryptedData = parsedEncryptionXml.encryption[
    "enc:encrypteddata"].
    find(encryptedData => {var _encryptedData$encEn, _encryptedData$encEn$;
      const method =
      encryptedData === null || encryptedData === void 0 ? void 0 : (_encryptedData$encEn = encryptedData["enc:encryptionmethod"]) === null || _encryptedData$encEn === void 0 ? void 0 : (_encryptedData$encEn$ = _encryptedData$encEn[0].attr) === null || _encryptedData$encEn$ === void 0 ? void 0 : _encryptedData$encEn$.algorithm;
      return (
        method.indexOf("ns.adobe.com/pdf/enc") ||
        method.indexOf("www.idpf.org/2008/embedding"));

    });
  }
  const obfMethod = (_fontEncryptedData =
  fontEncryptedData) === null || _fontEncryptedData === void 0 ? void 0 : (_fontEncryptedData$en = _fontEncryptedData["enc:encryptionmethod"]) === null || _fontEncryptedData$en === void 0 ? void 0 : (_fontEncryptedData$en2 = _fontEncryptedData$en[0].attr) === null || _fontEncryptedData$en2 === void 0 ? void 0 : _fontEncryptedData$en2.algorithm;

  if (obfMethod && obfMethod.indexOf("ns.adobe.com/pdf/enc") !== -1) {
    return adobeFontObfuscation(fontData, uniqueId);
  } else if (
  obfMethod &&
  obfMethod.indexOf("www.idpf.org/2008/embedding") !== -1)
  {
    return idpfFontObfuscation(fontData, uniqueId);
  }
}

/**
 * Obfuscates/Unobfuscates the provided font data using the IDPF method.
 * The Obfuscation process is a self-inverting XOR process. Running this
 * method on an onfuscated font will unobfuscate it and vice-versa
 * @param {Buffer | Uint8Array} fontData - source data
 * @param {string} identifier - the opf id used to produce the sha-1 key
 * @returns {Uint8array} - the output data
 */
function idpfFontObfuscation(fontData, identifier) {
  let outputData = Uint8Array.from(fontData);
  const byteMask = getIdpfKeyFromIdentifier(identifier);

  if (byteMask.length !== 20) {
    console.error("idpfFontObfuscation Error: key is not 20 bytes");
    return;
  }

  for (let i = 0; i < 1040 && i < outputData.length; ++i) {
    outputData[i] = outputData[i] ^ byteMask[i % 20];
  }
  return outputData;
}

/**
 * Obfuscates the provided font data using the Adobe method.
 * The Obfuscation process is a self-inverting XOR process. Running this
 * method on an onfuscated font will unobfuscate it and vice-versa
 * @param {Buffer | Uint8Array} fontData - source data
 * @param {string} identifier - the opf id used to produce the sha-1 key
 * @returns {Uint8array} - the output data
 */
function adobeFontObfuscation(fontData, identifier) {
  let outputData = Uint8Array.from(fontData);
  const byteMask = getAdobeKeyFromIdentifier(identifier);

  if (byteMask.length === 0) {
    console.error("idpfFontObfuscation Error: key is empty");
    return;
  }

  for (let i = 0; i < 1024 && i < outputData.length; ++i) {
    outputData[i] = outputData[i] ^ byteMask[i % byteMask.length];
  }
  return outputData;
}

/**
 * Converts the OPF UID into binary buffer array used by the adobe font obfuscation spec.
 * Unfortunetly this requires the node Buffer module. For browser support epubkit relies
 * on the Buffer polyfill proided by BrowserFS (see the webpack config).
 *
 * @param {string} id - the UUID identified in the epub's opf
 * @returns {Buffer}
 */
function getAdobeKeyFromIdentifier(id) {
  const cleanId = id.
  replace("urn:uuid:", "").
  replace(/-/g, "").
  replace(/:/g, "");

  // the key is treated as raw hex data.
  return Buffer.from(cleanId, "hex");
}

/**
 * Converts the OPF UID into a key used by the IDPF font obfuscation spec.
 * @param {string} id - the UUID identified in the epub's opf
 */
function getIdpfKeyFromIdentifier(id) {
  const cleanId = id.replace(/[\u0020\u0009\u000D\u000A]/g, "");
  const utf8Key = _utf.default.encode(cleanId);
  // "A SHA-1 digest of the UTF-8 representation of the resulting string"
  const sha = new _jssha.default("SHA-1", "TEXT", { encoding: "UTF8" });
  sha.update(utf8Key);
  const shaKey = sha.getHash("UINT8ARRAY");
  return shaKey;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9lcHViLWZvbnQtb2JmdXNjYXRvci5qcyJdLCJuYW1lcyI6WyJmb250T2JmdXNjYXRpb24iLCJmb250RGF0YSIsIm9wZlhtbCIsImVuY3J5cHRpb25YbWwiLCJmb250TG9jYXRpb24iLCJ1bmRlZmluZWQiLCJwYXJzZWRPcGZYbWwiLCJwYXJzZWRFbmNyeXB0aW9uWG1sIiwicGFja2FnZVVuaXF1ZUlkTmFtZSIsInBhY2thZ2UiLCJhdHRyIiwidW5pcXVlSWRFbCIsIm1ldGFkYXRhIiwiZmluZCIsImlkRWwiLCJpZCIsInVuaXF1ZUlkIiwidmFsIiwiZm9udEVuY3J5cHRlZERhdGEiLCJlbmNyeXB0aW9uIiwiZW5jcnlwdGVkRGF0YSIsImNpcGhlclJlZmVyZW5jZSIsInJlZiIsInVyaSIsIm1ldGhvZCIsImFsZ29yaXRobSIsImluZGV4T2YiLCJvYmZNZXRob2QiLCJhZG9iZUZvbnRPYmZ1c2NhdGlvbiIsImlkcGZGb250T2JmdXNjYXRpb24iLCJpZGVudGlmaWVyIiwib3V0cHV0RGF0YSIsIlVpbnQ4QXJyYXkiLCJmcm9tIiwiYnl0ZU1hc2siLCJnZXRJZHBmS2V5RnJvbUlkZW50aWZpZXIiLCJsZW5ndGgiLCJjb25zb2xlIiwiZXJyb3IiLCJpIiwiZ2V0QWRvYmVLZXlGcm9tSWRlbnRpZmllciIsImNsZWFuSWQiLCJyZXBsYWNlIiwiQnVmZmVyIiwidXRmOEtleSIsInV0ZjgiLCJlbmNvZGUiLCJzaGEiLCJqc1NIQSIsImVuY29kaW5nIiwidXBkYXRlIiwic2hhS2V5IiwiZ2V0SGFzaCJdLCJtYXBwaW5ncyI6InFWQUFBO0FBQ0E7QUFDQSxxQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLGVBQWVBLGVBQWY7QUFDTEMsUUFESztBQUVMQyxNQUZLO0FBR0xDLGFBSEs7QUFJTEMsWUFBWSxHQUFHQyxTQUpWO0FBS0w7QUFDQSxRQUFNQyxZQUFZLEdBQUcsTUFBTSxtQkFBU0osTUFBVCxDQUEzQjtBQUNBLFFBQU1LLG1CQUFtQixHQUFHLE1BQU0sbUJBQVNKLGFBQVQsQ0FBbEM7QUFDQSxRQUFNSyxtQkFBbUIsR0FBR0YsWUFBWSxDQUFDRyxPQUFiLENBQXFCQyxJQUFyQixDQUEwQixtQkFBMUIsQ0FBNUI7QUFDQSxRQUFNQyxVQUFVLEdBQUdMLFlBQVksQ0FBQ0csT0FBYixDQUFxQkcsUUFBckIsQ0FBOEIsQ0FBOUIsRUFBaUMsZUFBakMsRUFBa0RDLElBQWxEO0FBQ2hCQyxFQUFBQSxJQUFELElBQVU7QUFDUixXQUFPQSxJQUFJLENBQUNKLElBQUwsQ0FBVUssRUFBVixLQUFpQlAsbUJBQXhCO0FBQ0QsR0FIZ0IsQ0FBbkI7O0FBS0EsUUFBTVEsUUFBUSxHQUFHTCxVQUFVLENBQUNNLEdBQTVCOztBQUVBLE1BQUlDLGlCQUFKO0FBQ0EsTUFBSWQsWUFBSixFQUFrQjtBQUNoQjtBQUNBYyxJQUFBQSxpQkFBaUIsR0FBR1gsbUJBQUgsYUFBR0EsbUJBQUgsZ0RBQUdBLG1CQUFtQixDQUFFWSxVQUF4QiwwREFBRztBQUNsQix1QkFEa0I7QUFFbEJOLElBQUFBLElBRmtCLENBRVpPLGFBQUQsSUFBbUI7QUFDeEIsWUFBTUMsZUFBZSxHQUFHRCxhQUFILGFBQUdBLGFBQUgsK0NBQUdBLGFBQWEsQ0FBRyxnQkFBSCxDQUFoQixrRkFBRyxxQkFBb0MsQ0FBcEMsQ0FBSCwwREFBRztBQUN0QiwyQkFEc0I7QUFFdEJQLE1BQUFBLElBRnNCLENBRWhCUyxHQUFELElBQVNBLEdBQUcsQ0FBQ1osSUFBSixDQUFTYSxHQUFULEtBQWlCbkIsWUFGVCxDQUF4QjtBQUdBLFVBQUlpQixlQUFKLEVBQXFCO0FBQ25CLGVBQU8sSUFBUDtBQUNELE9BRkQsTUFFTztBQUNMLGVBQU8sS0FBUDtBQUNEO0FBQ0YsS0FYbUIsQ0FBcEI7QUFZRCxHQWRELE1BY087QUFDTDtBQUNBSCxJQUFBQSxpQkFBaUIsR0FBR1gsbUJBQW1CLENBQUNZLFVBQXBCO0FBQ2xCLHVCQURrQjtBQUVsQk4sSUFBQUEsSUFGa0IsQ0FFWk8sYUFBRCxJQUFtQjtBQUN4QixZQUFNSSxNQUFNO0FBQ1ZKLE1BQUFBLGFBRFUsYUFDVkEsYUFEVSwrQ0FDVkEsYUFBYSxDQUFHLHNCQUFILENBREgsa0ZBQ1YscUJBQTBDLENBQTFDLEVBQTZDVixJQURuQywwREFDVixzQkFBbURlLFNBRHJEO0FBRUE7QUFDRUQsUUFBQUEsTUFBTSxDQUFDRSxPQUFQLENBQWUsc0JBQWY7QUFDQUYsUUFBQUEsTUFBTSxDQUFDRSxPQUFQLENBQWUsNkJBQWYsQ0FGRjs7QUFJRCxLQVRtQixDQUFwQjtBQVVEO0FBQ0QsUUFBTUMsU0FBUztBQUNiVCxFQUFBQSxpQkFEYSxnRkFDYixtQkFBb0Isc0JBQXBCLENBRGEsb0ZBQ2Isc0JBQThDLENBQTlDLEVBQWlEUixJQURwQywyREFDYix1QkFBdURlLFNBRHpEOztBQUdBLE1BQUlFLFNBQVMsSUFBSUEsU0FBUyxDQUFDRCxPQUFWLENBQWtCLHNCQUFsQixNQUE4QyxDQUFDLENBQWhFLEVBQW1FO0FBQ2pFLFdBQU9FLG9CQUFvQixDQUFDM0IsUUFBRCxFQUFXZSxRQUFYLENBQTNCO0FBQ0QsR0FGRCxNQUVPO0FBQ0xXLEVBQUFBLFNBQVM7QUFDVEEsRUFBQUEsU0FBUyxDQUFDRCxPQUFWLENBQWtCLDZCQUFsQixNQUFxRCxDQUFDLENBRmpEO0FBR0w7QUFDQSxXQUFPRyxtQkFBbUIsQ0FBQzVCLFFBQUQsRUFBV2UsUUFBWCxDQUExQjtBQUNEO0FBQ0Y7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLFNBQVNhLG1CQUFULENBQTZCNUIsUUFBN0IsRUFBdUM2QixVQUF2QyxFQUFtRDtBQUN4RCxNQUFJQyxVQUFVLEdBQUdDLFVBQVUsQ0FBQ0MsSUFBWCxDQUFnQmhDLFFBQWhCLENBQWpCO0FBQ0EsUUFBTWlDLFFBQVEsR0FBR0Msd0JBQXdCLENBQUNMLFVBQUQsQ0FBekM7O0FBRUEsTUFBSUksUUFBUSxDQUFDRSxNQUFULEtBQW9CLEVBQXhCLEVBQTRCO0FBQzFCQyxJQUFBQSxPQUFPLENBQUNDLEtBQVIsQ0FBYyxnREFBZDtBQUNBO0FBQ0Q7O0FBRUQsT0FBSyxJQUFJQyxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHLElBQUosSUFBWUEsQ0FBQyxHQUFHUixVQUFVLENBQUNLLE1BQTNDLEVBQW1ELEVBQUVHLENBQXJELEVBQXdEO0FBQ3REUixJQUFBQSxVQUFVLENBQUNRLENBQUQsQ0FBVixHQUFnQlIsVUFBVSxDQUFDUSxDQUFELENBQVYsR0FBZ0JMLFFBQVEsQ0FBQ0ssQ0FBQyxHQUFHLEVBQUwsQ0FBeEM7QUFDRDtBQUNELFNBQU9SLFVBQVA7QUFDRDs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sU0FBU0gsb0JBQVQsQ0FBOEIzQixRQUE5QixFQUF3QzZCLFVBQXhDLEVBQW9EO0FBQ3pELE1BQUlDLFVBQVUsR0FBR0MsVUFBVSxDQUFDQyxJQUFYLENBQWdCaEMsUUFBaEIsQ0FBakI7QUFDQSxRQUFNaUMsUUFBUSxHQUFHTSx5QkFBeUIsQ0FBQ1YsVUFBRCxDQUExQzs7QUFFQSxNQUFJSSxRQUFRLENBQUNFLE1BQVQsS0FBb0IsQ0FBeEIsRUFBMkI7QUFDekJDLElBQUFBLE9BQU8sQ0FBQ0MsS0FBUixDQUFjLHlDQUFkO0FBQ0E7QUFDRDs7QUFFRCxPQUFLLElBQUlDLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUcsSUFBSixJQUFZQSxDQUFDLEdBQUdSLFVBQVUsQ0FBQ0ssTUFBM0MsRUFBbUQsRUFBRUcsQ0FBckQsRUFBd0Q7QUFDdERSLElBQUFBLFVBQVUsQ0FBQ1EsQ0FBRCxDQUFWLEdBQWdCUixVQUFVLENBQUNRLENBQUQsQ0FBVixHQUFnQkwsUUFBUSxDQUFDSyxDQUFDLEdBQUdMLFFBQVEsQ0FBQ0UsTUFBZCxDQUF4QztBQUNEO0FBQ0QsU0FBT0wsVUFBUDtBQUNEOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxTQUFTUyx5QkFBVCxDQUFtQ3pCLEVBQW5DLEVBQXVDO0FBQzVDLFFBQU0wQixPQUFPLEdBQUcxQixFQUFFO0FBQ2YyQixFQUFBQSxPQURhLENBQ0wsV0FESyxFQUNRLEVBRFI7QUFFYkEsRUFBQUEsT0FGYSxDQUVMLElBRkssRUFFQyxFQUZEO0FBR2JBLEVBQUFBLE9BSGEsQ0FHTCxJQUhLLEVBR0MsRUFIRCxDQUFoQjs7QUFLQTtBQUNBLFNBQU9DLE1BQU0sQ0FBQ1YsSUFBUCxDQUFZUSxPQUFaLEVBQXFCLEtBQXJCLENBQVA7QUFDRDs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNPLFNBQVNOLHdCQUFULENBQWtDcEIsRUFBbEMsRUFBc0M7QUFDM0MsUUFBTTBCLE9BQU8sR0FBRzFCLEVBQUUsQ0FBQzJCLE9BQUgsQ0FBVyw2QkFBWCxFQUEwQyxFQUExQyxDQUFoQjtBQUNBLFFBQU1FLE9BQU8sR0FBR0MsYUFBS0MsTUFBTCxDQUFZTCxPQUFaLENBQWhCO0FBQ0E7QUFDQSxRQUFNTSxHQUFHLEdBQUcsSUFBSUMsY0FBSixDQUFVLE9BQVYsRUFBbUIsTUFBbkIsRUFBMkIsRUFBRUMsUUFBUSxFQUFFLE1BQVosRUFBM0IsQ0FBWjtBQUNBRixFQUFBQSxHQUFHLENBQUNHLE1BQUosQ0FBV04sT0FBWDtBQUNBLFFBQU1PLE1BQU0sR0FBR0osR0FBRyxDQUFDSyxPQUFKLENBQVksWUFBWixDQUFmO0FBQ0EsU0FBT0QsTUFBUDtBQUNEIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGpzU0hBIGZyb20gXCJqc3NoYVwiO1xuaW1wb3J0IHV0ZjggZnJvbSBcInV0ZjhcIjtcbmltcG9ydCB7IHBhcnNlWG1sIH0gZnJvbSBcIi4vdXRpbHMveG1sLmpzXCI7XG5cbi8qKlxuICogVGhlIEVwdWIgZm9udCBvYmZ1c2NhdGlvbiBzcGVjIGlzIGEgc2VsZi1pbnZlcnRpbmcgWE9SIHByb2Nlc3MuXG4gKiBUbyB1bm9iZnVzY2F0ZSBqdXN0IHJ1biB0aGUgb2JmdXNjYXRlZCBmb250IHRocm91Z2ggdGhlIG9iZnVzY2F0b3IgYWdhaW4uXG4gKiBCYXNlZCBvbiB0aGUgamF2YSBpbXBsZW1lbnRhdGlvbnMgZm91bmQgYXRcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9kaXRhNHB1Ymxpc2hlcnMvZXB1Yi1mb250LW9iZnVzY2F0b3JcbiAqIGFuZCB0aGUgQysrIGltcGxlbWVudGF0aW9uIGF0OlxuICogaHR0cHM6Ly9naXRodWIuY29tL1NpZ2lsLUVib29rL1NpZ2lsL2Jsb2IvbWFzdGVyL3NyYy9NaXNjL0ZvbnRPYmZ1c2NhdGlvbi5jcHBcbiAqXG4gKiBUaGUgc3BlYyBpcyBmb3VuZCBhdDpcbiAqIGh0dHBzOi8vd3d3LnczLm9yZy9wdWJsaXNoaW5nL2VwdWIzMi9lcHViLW9jZi5odG1sI3NlYy1yZXNvdXJjZS1vYmZ1c2NhdGlvblxuICovXG5cbi8qKlxuICogVXNlcyB0aGUgZGF0YSBmcm9tIHRoZSBwYWNrYWdlIE9wZiBhbmQgZW5jcnlwdGlvbi54bWwgdG8gZmluZCBvYmZ1c2NhdGlvbiBtZXRob2QgYW5kIGtleVxuICogVE9ETzogdGhpcyBhc3N1bWVzIHRoYXQgYWxsIGZvbnRzIGFyZSBvYmZ1c2NhdGVkIHdpdGggdGhlIHNhbWUgbWV0aG9kXG4gKiBUaGUgZm9udExvY2F0aW9uIG9wdGlvbiBzaG91bGQgYmUgdXNlZCB0byBpZCB0aGUgZm9udCBvYmZ1c2NhdGlvbiBtZXRob2Qgd2l0aGluIGVuY3JweXRpb24ueG1sXG4gKiBAcGFyYW0ge0J1ZmZlciB8IFVpbnQ4QXJyYXl9IGZvbnREYXRhIC0gc291cmNlIGZvbnQgZGF0YVxuICogQHBhcmFtIHtzdHJpbmd9IG9wZlhtbCAtIHhtbCBvZiBvcGYgZmlsZVxuICogQHBhcmFtIHtzdHJpbmd9IGVuY3J5cHRpb25YbWwgLSB4bWwgb2YgZW5jcnlwdGlvbi54bWwgZmlsZVxuICogQHBhcmFtIHtzdHJpbmd9IGZvbnRMb2NhdGlvbiAtIChvcHRpb25hbCkgdGhlIGxvY2F0aW9uIG9mIHRoZSBmb250IHJlbGF0aXZlIHRvIHRoZSBlcHViIHJvb3RcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGZvbnRPYmZ1c2NhdGlvbihcbiAgZm9udERhdGEsXG4gIG9wZlhtbCxcbiAgZW5jcnlwdGlvblhtbCxcbiAgZm9udExvY2F0aW9uID0gdW5kZWZpbmVkXG4pIHtcbiAgY29uc3QgcGFyc2VkT3BmWG1sID0gYXdhaXQgcGFyc2VYbWwob3BmWG1sKTtcbiAgY29uc3QgcGFyc2VkRW5jcnlwdGlvblhtbCA9IGF3YWl0IHBhcnNlWG1sKGVuY3J5cHRpb25YbWwpO1xuICBjb25zdCBwYWNrYWdlVW5pcXVlSWROYW1lID0gcGFyc2VkT3BmWG1sLnBhY2thZ2UuYXR0cltcInVuaXF1ZS1pZGVudGlmaWVyXCJdO1xuICBjb25zdCB1bmlxdWVJZEVsID0gcGFyc2VkT3BmWG1sLnBhY2thZ2UubWV0YWRhdGFbMF1bXCJkYzppZGVudGlmaWVyXCJdLmZpbmQoXG4gICAgKGlkRWwpID0+IHtcbiAgICAgIHJldHVybiBpZEVsLmF0dHIuaWQgPT09IHBhY2thZ2VVbmlxdWVJZE5hbWU7XG4gICAgfVxuICApO1xuICBjb25zdCB1bmlxdWVJZCA9IHVuaXF1ZUlkRWwudmFsO1xuXG4gIGxldCBmb250RW5jcnlwdGVkRGF0YTtcbiAgaWYgKGZvbnRMb2NhdGlvbikge1xuICAgIC8vIGlmIGZvbnRMb2NhdGlvbiBpcyBwcm92aWRlZCwgbG9vayBmb3IgaXQgaW4gdGhlIGVuY3J5cHRpb24gcmVmZXJlbmNlc1xuICAgIGZvbnRFbmNyeXB0ZWREYXRhID0gcGFyc2VkRW5jcnlwdGlvblhtbD8uZW5jcnlwdGlvbj8uW1xuICAgICAgXCJlbmM6ZW5jcnlwdGVkZGF0YVwiXG4gICAgXS5maW5kKChlbmNyeXB0ZWREYXRhKSA9PiB7XG4gICAgICBjb25zdCBjaXBoZXJSZWZlcmVuY2UgPSBlbmNyeXB0ZWREYXRhPy5bXCJlbmM6Y2lwaGVyZGF0YVwiXT8uWzBdPy5bXG4gICAgICAgIFwiZW5jOmNpcGhlcnJlZmVyZW5jZVwiXG4gICAgICBdLmZpbmQoKHJlZikgPT4gcmVmLmF0dHIudXJpID09PSBmb250TG9jYXRpb24pO1xuICAgICAgaWYgKGNpcGhlclJlZmVyZW5jZSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICAvLyBvdGhlcndpc2UgbG9vayB0byBzZWUgaWYgZWl0aGVyIGFkb2JlIG9yIGlkcGYgaXMgbGlzdGVkIGF0IGFsbCBhbmQgdGFrZSB0aGUgZmlyc3Qgb25lIGZvdW5kXG4gICAgZm9udEVuY3J5cHRlZERhdGEgPSBwYXJzZWRFbmNyeXB0aW9uWG1sLmVuY3J5cHRpb25bXG4gICAgICBcImVuYzplbmNyeXB0ZWRkYXRhXCJcbiAgICBdLmZpbmQoKGVuY3J5cHRlZERhdGEpID0+IHtcbiAgICAgIGNvbnN0IG1ldGhvZCA9XG4gICAgICAgIGVuY3J5cHRlZERhdGE/LltcImVuYzplbmNyeXB0aW9ubWV0aG9kXCJdPy5bMF0uYXR0cj8uYWxnb3JpdGhtO1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgbWV0aG9kLmluZGV4T2YoXCJucy5hZG9iZS5jb20vcGRmL2VuY1wiKSB8fFxuICAgICAgICBtZXRob2QuaW5kZXhPZihcInd3dy5pZHBmLm9yZy8yMDA4L2VtYmVkZGluZ1wiKVxuICAgICAgKTtcbiAgICB9KTtcbiAgfVxuICBjb25zdCBvYmZNZXRob2QgPVxuICAgIGZvbnRFbmNyeXB0ZWREYXRhPy5bXCJlbmM6ZW5jcnlwdGlvbm1ldGhvZFwiXT8uWzBdLmF0dHI/LmFsZ29yaXRobTtcblxuICBpZiAob2JmTWV0aG9kICYmIG9iZk1ldGhvZC5pbmRleE9mKFwibnMuYWRvYmUuY29tL3BkZi9lbmNcIikgIT09IC0xKSB7XG4gICAgcmV0dXJuIGFkb2JlRm9udE9iZnVzY2F0aW9uKGZvbnREYXRhLCB1bmlxdWVJZCk7XG4gIH0gZWxzZSBpZiAoXG4gICAgb2JmTWV0aG9kICYmXG4gICAgb2JmTWV0aG9kLmluZGV4T2YoXCJ3d3cuaWRwZi5vcmcvMjAwOC9lbWJlZGRpbmdcIikgIT09IC0xXG4gICkge1xuICAgIHJldHVybiBpZHBmRm9udE9iZnVzY2F0aW9uKGZvbnREYXRhLCB1bmlxdWVJZCk7XG4gIH1cbn1cblxuLyoqXG4gKiBPYmZ1c2NhdGVzL1Vub2JmdXNjYXRlcyB0aGUgcHJvdmlkZWQgZm9udCBkYXRhIHVzaW5nIHRoZSBJRFBGIG1ldGhvZC5cbiAqIFRoZSBPYmZ1c2NhdGlvbiBwcm9jZXNzIGlzIGEgc2VsZi1pbnZlcnRpbmcgWE9SIHByb2Nlc3MuIFJ1bm5pbmcgdGhpc1xuICogbWV0aG9kIG9uIGFuIG9uZnVzY2F0ZWQgZm9udCB3aWxsIHVub2JmdXNjYXRlIGl0IGFuZCB2aWNlLXZlcnNhXG4gKiBAcGFyYW0ge0J1ZmZlciB8IFVpbnQ4QXJyYXl9IGZvbnREYXRhIC0gc291cmNlIGRhdGFcbiAqIEBwYXJhbSB7c3RyaW5nfSBpZGVudGlmaWVyIC0gdGhlIG9wZiBpZCB1c2VkIHRvIHByb2R1Y2UgdGhlIHNoYS0xIGtleVxuICogQHJldHVybnMge1VpbnQ4YXJyYXl9IC0gdGhlIG91dHB1dCBkYXRhXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpZHBmRm9udE9iZnVzY2F0aW9uKGZvbnREYXRhLCBpZGVudGlmaWVyKSB7XG4gIGxldCBvdXRwdXREYXRhID0gVWludDhBcnJheS5mcm9tKGZvbnREYXRhKTtcbiAgY29uc3QgYnl0ZU1hc2sgPSBnZXRJZHBmS2V5RnJvbUlkZW50aWZpZXIoaWRlbnRpZmllcik7XG5cbiAgaWYgKGJ5dGVNYXNrLmxlbmd0aCAhPT0gMjApIHtcbiAgICBjb25zb2xlLmVycm9yKFwiaWRwZkZvbnRPYmZ1c2NhdGlvbiBFcnJvcjoga2V5IGlzIG5vdCAyMCBieXRlc1wiKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBmb3IgKGxldCBpID0gMDsgaSA8IDEwNDAgJiYgaSA8IG91dHB1dERhdGEubGVuZ3RoOyArK2kpIHtcbiAgICBvdXRwdXREYXRhW2ldID0gb3V0cHV0RGF0YVtpXSBeIGJ5dGVNYXNrW2kgJSAyMF07XG4gIH1cbiAgcmV0dXJuIG91dHB1dERhdGE7XG59XG5cbi8qKlxuICogT2JmdXNjYXRlcyB0aGUgcHJvdmlkZWQgZm9udCBkYXRhIHVzaW5nIHRoZSBBZG9iZSBtZXRob2QuXG4gKiBUaGUgT2JmdXNjYXRpb24gcHJvY2VzcyBpcyBhIHNlbGYtaW52ZXJ0aW5nIFhPUiBwcm9jZXNzLiBSdW5uaW5nIHRoaXNcbiAqIG1ldGhvZCBvbiBhbiBvbmZ1c2NhdGVkIGZvbnQgd2lsbCB1bm9iZnVzY2F0ZSBpdCBhbmQgdmljZS12ZXJzYVxuICogQHBhcmFtIHtCdWZmZXIgfCBVaW50OEFycmF5fSBmb250RGF0YSAtIHNvdXJjZSBkYXRhXG4gKiBAcGFyYW0ge3N0cmluZ30gaWRlbnRpZmllciAtIHRoZSBvcGYgaWQgdXNlZCB0byBwcm9kdWNlIHRoZSBzaGEtMSBrZXlcbiAqIEByZXR1cm5zIHtVaW50OGFycmF5fSAtIHRoZSBvdXRwdXQgZGF0YVxuICovXG5leHBvcnQgZnVuY3Rpb24gYWRvYmVGb250T2JmdXNjYXRpb24oZm9udERhdGEsIGlkZW50aWZpZXIpIHtcbiAgbGV0IG91dHB1dERhdGEgPSBVaW50OEFycmF5LmZyb20oZm9udERhdGEpO1xuICBjb25zdCBieXRlTWFzayA9IGdldEFkb2JlS2V5RnJvbUlkZW50aWZpZXIoaWRlbnRpZmllcik7XG5cbiAgaWYgKGJ5dGVNYXNrLmxlbmd0aCA9PT0gMCkge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJpZHBmRm9udE9iZnVzY2F0aW9uIEVycm9yOiBrZXkgaXMgZW1wdHlcIik7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCAxMDI0ICYmIGkgPCBvdXRwdXREYXRhLmxlbmd0aDsgKytpKSB7XG4gICAgb3V0cHV0RGF0YVtpXSA9IG91dHB1dERhdGFbaV0gXiBieXRlTWFza1tpICUgYnl0ZU1hc2subGVuZ3RoXTtcbiAgfVxuICByZXR1cm4gb3V0cHV0RGF0YTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyB0aGUgT1BGIFVJRCBpbnRvIGJpbmFyeSBidWZmZXIgYXJyYXkgdXNlZCBieSB0aGUgYWRvYmUgZm9udCBvYmZ1c2NhdGlvbiBzcGVjLlxuICogVW5mb3J0dW5ldGx5IHRoaXMgcmVxdWlyZXMgdGhlIG5vZGUgQnVmZmVyIG1vZHVsZS4gRm9yIGJyb3dzZXIgc3VwcG9ydCBlcHVia2l0IHJlbGllc1xuICogb24gdGhlIEJ1ZmZlciBwb2x5ZmlsbCBwcm9pZGVkIGJ5IEJyb3dzZXJGUyAoc2VlIHRoZSB3ZWJwYWNrIGNvbmZpZykuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGlkIC0gdGhlIFVVSUQgaWRlbnRpZmllZCBpbiB0aGUgZXB1YidzIG9wZlxuICogQHJldHVybnMge0J1ZmZlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEFkb2JlS2V5RnJvbUlkZW50aWZpZXIoaWQpIHtcbiAgY29uc3QgY2xlYW5JZCA9IGlkXG4gICAgLnJlcGxhY2UoXCJ1cm46dXVpZDpcIiwgXCJcIilcbiAgICAucmVwbGFjZSgvLS9nLCBcIlwiKVxuICAgIC5yZXBsYWNlKC86L2csIFwiXCIpO1xuXG4gIC8vIHRoZSBrZXkgaXMgdHJlYXRlZCBhcyByYXcgaGV4IGRhdGEuXG4gIHJldHVybiBCdWZmZXIuZnJvbShjbGVhbklkLCBcImhleFwiKTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyB0aGUgT1BGIFVJRCBpbnRvIGEga2V5IHVzZWQgYnkgdGhlIElEUEYgZm9udCBvYmZ1c2NhdGlvbiBzcGVjLlxuICogQHBhcmFtIHtzdHJpbmd9IGlkIC0gdGhlIFVVSUQgaWRlbnRpZmllZCBpbiB0aGUgZXB1YidzIG9wZlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0SWRwZktleUZyb21JZGVudGlmaWVyKGlkKSB7XG4gIGNvbnN0IGNsZWFuSWQgPSBpZC5yZXBsYWNlKC9bXFx1MDAyMFxcdTAwMDlcXHUwMDBEXFx1MDAwQV0vZywgXCJcIik7XG4gIGNvbnN0IHV0ZjhLZXkgPSB1dGY4LmVuY29kZShjbGVhbklkKTtcbiAgLy8gXCJBIFNIQS0xIGRpZ2VzdCBvZiB0aGUgVVRGLTggcmVwcmVzZW50YXRpb24gb2YgdGhlIHJlc3VsdGluZyBzdHJpbmdcIlxuICBjb25zdCBzaGEgPSBuZXcganNTSEEoXCJTSEEtMVwiLCBcIlRFWFRcIiwgeyBlbmNvZGluZzogXCJVVEY4XCIgfSk7XG4gIHNoYS51cGRhdGUodXRmOEtleSk7XG4gIGNvbnN0IHNoYUtleSA9IHNoYS5nZXRIYXNoKFwiVUlOVDhBUlJBWVwiKTtcbiAgcmV0dXJuIHNoYUtleTtcbn1cbiJdfQ==